# biim LL-HLS streamer overview

The `streamer_biim.py` pipeline captures live video with FFmpeg, encodes H.264 and AAC using low-latency settings (`-tune zerolatency` and a GOP capped by `--key-int-max`), and emits MPEG-TS to stdout. biim’s `Fmp4VariantHandler` demuxes that transport stream in real time and packages it into fMP4 partial segments and full segments entirely in memory, avoiding disk I/O. An aiohttp server then exposes the LL-HLS surface: `/playlist.m3u8` (alias `/live.m3u8`), `/part`, `/segment`, `/init`, and `/timestamps.json` for latency probes. Segment and part URLs are expressed as query endpoints (`segment?msn=N`, `part?msn=N&part=P`) so players can use blocking reloads, and all playlist responses are served with `Cache-Control: no-store` to prevent stale manifests.

The generated manifest follows Apple’s LL-HLS guidance. It declares `#EXT-X-VERSION:9` so low-latency tags are honored, advertises `#EXT-X-SERVER-CONTROL:CAN-BLOCK-RELOAD=YES` for blocking reloads, and includes `#EXT-X-PRELOAD-HINT` to announce the next part as it is being written. Partial segments are described with `#EXT-X-PART-INF:PART-TARGET=0.1` and per-part `#EXT-X-PART` entries for roughly 100 ms chunks. The default target duration is about one second with a part-hold-back of roughly three times the part target, matching Apple’s recommended minima. A live window of five segments keeps the playlist small and focused on the live edge, and chunked HTTP/1.1 responses deliver parts as they are produced.

Several parameters can be tuned to push latency lower, each with trade-offs. Reducing `--part-duration` below 100 ms trims glass-to-glass time but increases HTTP overhead and sensitivity to jitter. Lowering `--target-duration` cuts live-edge distance, but only if GOP length (`--key-int-max`) stays at or below the segment size; otherwise segments wait for the next IDR and stability can suffer. Tightening `--key-int-max` (for example, 15 for 30 fps to get ~0.5 s GOP) yields quicker segment boundaries but raises bitrate and encoder load. Using faster x264 presets keeps encoding delay small at the expense of quality and efficiency, while slower presets add latency. Shrinking `--window-size` keeps the manifest lean but reduces rewind and recovery headroom. Additional FFmpeg flags such as `-fflags nobuffer -flags low_delay -probesize 32 -analyzeduration 0 -flush_packets 1 -muxdelay 0 -muxpreload 0 -rtbufsize 0` can squeeze out buffering inside the encoder/muxer, though they may make the pipeline more brittle on slower hardware. On the player side, more aggressive hls.js settings (lower live sync and max buffer) can reduce end-to-end delay but increase the likelihood of rebuffering if the network is uneven.

Operationally, test directly against `http://<host>:8080/playlist.m3u8` served by the biim pipeline rather than the disk-backed `output/live.m3u8` from the GStreamer path. Avoid buffering proxies or CDNs, or disable proxy buffering so chunked responses pass through. Keep GOP length at or below segment duration, and ensure NTP synchronization between server and client when using `/timestamps.json` for latency measurements. This combination preserves low latency while keeping the stream stable for typical LL-HLS players.
